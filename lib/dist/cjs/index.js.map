{"mappings":"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","sources":["elements/context.ts","elements/hooks.ts","elements/reducer.ts","elements/provider.tsx","Connect.tsx","lines/utils/pathify.ts","lines/utils/getElement.ts","lines/utils/getGroupedConnections.ts","lines/utils/getPathData.ts","lines/ConnectLines.tsx","ConnectProvider.tsx"],"sourcesContent":["import {createContext} from 'react'\nimport {ConnectElementsContextValue} from '../types'\n\nexport const ConnectElementsContext = createContext<ConnectElementsContextValue>({\n  elements: [],\n  dispatch: () => null,\n})\n","import {useContext} from 'react'\nimport {ConnectElementsContext} from './context'\n\nexport function useConnectElements() {\n  const ctxVal = useContext(ConnectElementsContext)\n\n  if (!ctxVal) {\n    throw new Error('Missing context value')\n  }\n\n  return useContext(ConnectElementsContext)\n}\n","import {ConnectElement, ConnectElementsContextValue, ConnectElementsReducerPayload} from '../types'\n\nexport function connectElementsReducer(\n  state: ConnectElementsContextValue,\n  payload: ConnectElementsReducerPayload\n): ConnectElementsContextValue {\n  const {type, id, element, connectWith} = payload\n\n  const exists = state?.elements?.some((l) => l.id === id)\n  const connectWithArr = connectWith || []\n  const node: ConnectElement & {element?: HTMLElement | null} = {\n    id,\n    element,\n    connectWith: connectWithArr,\n  }\n\n  if (type === 'add' && element) {\n    if (!exists) {\n      return {\n        ...state,\n        elements: [...state.elements, node],\n      }\n    }\n\n    if (exists) {\n      const next = [...state.elements].map((el) => {\n        if (el.id === id) {\n          return node\n        }\n\n        return el\n      })\n\n      return {...state, elements: next}\n    }\n\n    return state\n  }\n\n  if (type === 'remove') {\n    return {\n      ...state,\n      elements: state.elements\n        .map((x) => {\n          return {\n            ...x,\n            connectWith: x.connectWith?.filter((y) => y.id !== id),\n          }\n        })\n        .filter((el) => el.id !== id),\n    }\n  }\n\n  return state\n}\n","import {useMemo, useReducer} from 'react'\nimport {ConnectElementsContext} from './context'\nimport {connectElementsReducer} from './reducer'\n\ninterface ConnectElementsProviderProps {\n  children: React.ReactNode\n}\n\nexport function ConnectElementsProvider(props: ConnectElementsProviderProps) {\n  const {children} = props\n  const [state, dispatch] = useReducer(connectElementsReducer, {\n    elements: [],\n    dispatch: () => null,\n  })\n\n  const ctxVal = useMemo(\n    () => ({\n      elements: state.elements,\n      dispatch: dispatch,\n    }),\n    [state]\n  )\n\n  return (\n    <ConnectElementsContext.Provider value={ctxVal}>{children}</ConnectElementsContext.Provider>\n  )\n}\n","import React, {cloneElement, useCallback, useEffect, useMemo, useRef} from 'react'\nimport {useConnectElements} from './elements'\nimport {ConnectElement} from './types'\n\ninterface ConnectProps extends Omit<ConnectElement, 'element'> {\n  children: React.ReactElement\n}\n\nexport function Connect(props: ConnectProps) {\n  const {children, id, connectWith} = props\n  const {dispatch} = useConnectElements()\n  const nodeRef = useRef<HTMLElement>()\n\n  const handleAdd = useCallback(() => {\n    dispatch({\n      type: 'add',\n      id,\n      connectWith,\n      element: nodeRef.current,\n    })\n  }, [connectWith, dispatch, id])\n\n  const clone = useMemo(() => {\n    const {props: childProps} = children\n\n    return cloneElement(children, {\n      ...childProps,\n      ref: (node: HTMLElement) => {\n        nodeRef.current = node\n\n        if (typeof children === 'function') childProps.ref(node)\n      },\n    })\n  }, [children])\n\n  useEffect(() => {\n    handleAdd()\n  }, [props, handleAdd, nodeRef])\n\n  useEffect(() => {\n    return () => {\n      dispatch({\n        type: 'remove',\n        id,\n      })\n    }\n  }, [dispatch, id])\n\n  return clone\n}\n","import {Edge} from '../../types'\n\ninterface PathifyProps {\n  paths: {x: string | number; y: string | number}[]\n  edge?: Edge\n}\n\nexport const pathify = (props: PathifyProps) => {\n  const {paths, edge} = props\n\n  const path = `M ${paths\n    .map((p, index) => {\n      if (index === 1 && edge === 'step') return `${p.x} ${p.y}`\n      if (index === 1 && edge === 'bezier') return `C ${p.x} ${p.y}`\n\n      return `${p.x} ${p.y}`\n    })\n    .join(' ')}`\n\n  return path\n}\n","import {ConnectElement} from '../../types'\n\nexport function getElement(el: ConnectElement & {element?: HTMLElement}) {\n  if (!el.element) {\n    return document.querySelector(`#${el.id}`)\n  }\n\n  return el.element\n}\n","import {ConnectElement} from '../../types'\nimport {getElement} from './getElement'\n\nconst EMPTY_ARRAY: [] = []\n\ninterface GetGroupedConnectionsProps {\n  elements: ConnectElement[]\n}\n\nexport function getGroupedConnections(props: GetGroupedConnectionsProps) {\n  const {elements} = props\n\n  // const connections = elements?.map((e) => e.connectWith?.map((x) => x?.id)).flat()\n\n  const grouped = elements\n    .filter((e) => (e?.connectWith || EMPTY_ARRAY).length > 0)\n    .map((el) => {\n      const {connectWith} = el\n\n      // const connectionsLen = connections.filter((y) => y === el.id)?.length || 0\n\n      const connectEls = elements\n        .filter((c) => connectWith?.map((a) => a.id).includes(c.id))\n        .map((x) => {\n          return {\n            rect: getElement(x)?.getBoundingClientRect(),\n            color: connectWith?.find((a) => a.id === x.id)?.color || '#000000',\n            edge: connectWith?.find((a) => a.id === x.id)?.edge || 'bezier',\n            stroke: connectWith?.find((a) => a.id === x.id)?.stroke || 'solid',\n            hasArrows: Boolean(connectWith?.find((a) => a.id === x.id)?.hasArrows),\n            // connectionsLen: connectionsLen,\n          }\n        })\n\n      if (connectEls.length === 0) return\n\n      return {\n        from: {\n          rect: getElement(el)?.getBoundingClientRect(),\n        },\n        to: connectEls,\n      }\n    })\n    .filter(Boolean)\n\n  return grouped\n}\n","interface GetPathDataProps {\n  from?: {\n    rect: DOMRect | undefined\n  }\n  to?: {\n    rect: DOMRect | undefined\n  }\n}\n\nconst LINE_OFFSET = 9\nconst POS_OFFSET = 40\n\nfunction getPosition(props: {from: DOMRect; to: DOMRect}) {\n  const {from, to} = props\n\n  const allowYConnect =\n    from.left - POS_OFFSET < to.right && from.right + to.width > to.right - POS_OFFSET\n\n  const bottomToTop = from.bottom < to.top && allowYConnect\n  const topToBottom = from.top > to.bottom && allowYConnect\n  const rightToLeft = from.left > to.right\n  const leftToRight = from.right < to.left\n\n  if (bottomToTop) return 'bottom-to-top'\n  if (topToBottom) return 'top-to-bottom'\n  if (rightToLeft) return 'right-to-left'\n  if (leftToRight) return 'left-to-right'\n}\n\nexport function getPathData(props: GetPathDataProps) {\n  const {from, to} = props\n  const fromRect = from?.rect\n  const toRect = to?.rect\n\n  if (!fromRect || !toRect) return\n\n  const position = getPosition({from: fromRect, to: toRect})\n\n  switch (position) {\n    case 'bottom-to-top': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.bottom,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.top - LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'top-to-bottom': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.top,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.bottom + LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'right-to-left': {\n      return [\n        {\n          x: fromRect?.left,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.right + LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    case 'left-to-right': {\n      return [\n        {\n          x: fromRect?.right,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.left - LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    default:\n      return []\n  }\n}\n","import {useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {ConnectElement, Edge, Stroke} from '../types'\nimport {getElement, getGroupedConnections, getPathData, pathify} from './utils'\n\nconst SVG_STYLE: React.CSSProperties = {\n  position: 'fixed',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  pointerEvents: 'none',\n  width: '100%',\n  height: '100%',\n}\n\nconst DEFAULT_COLOR = '#000000'\nconst EMPTY_ARRAY: [] = []\n\ntype PointsData = (\n  | {\n      rect: DOMRect | undefined\n      color: string | undefined\n      edge: Edge\n      stroke: Stroke\n      d: string\n      hasArrows: boolean\n    }\n  | undefined\n)[]\n\ninterface ConnectLinesProps {\n  elements: ConnectElement[]\n}\n\nexport function ConnectLines(props: ConnectLinesProps) {\n  const [pointsData, setPointsData] = useState<PointsData>(EMPTY_ARRAY)\n  const [isInteracting, setIsInteracting] = useState<boolean>(false)\n  const {elements} = props\n  const raf = useRef<number>()\n\n  /**\n   * Create array of all colors configured.\n   * These colors is used to render the svg markers (e.g arrows).\n   */\n  const colors = useMemo(\n    () =>\n      [\n        ...new Set([\n          ...elements.map((e) => e.connectWith?.map((c) => c?.color)).flat(),\n          DEFAULT_COLOR,\n        ]),\n      ].filter(Boolean),\n    [elements]\n  )\n\n  const handleCalcLines = useCallback(() => {\n    if (raf.current) {\n      window.cancelAnimationFrame(raf.current)\n    }\n\n    raf.current = window.requestAnimationFrame(() => {\n      /**\n       * The `getGroupedConnections` function returns:\n       *\n       *  {\n       *    from: DOMRect,\n       *    to: {\n       *       rect: DOMRect,\n       *       color: string,\n       *       edge: string,\n       *       stroke: string,\n       *       hasArrows: boolean\n       *    }[]\n       *  }\n       */\n      const groupedConnections = getGroupedConnections({elements})\n\n      const points = groupedConnections\n        .map((data) => {\n          const {from, to: toArray} = data || {}\n\n          const pathDataArr = toArray?.map((to) => {\n            /**\n             * The `getPathData` function returns an array of objects with\n             * x and y coordinates for the line.\n             */\n            const pathData = getPathData({from: from, to: to})\n\n            if (!pathData) return\n\n            /**\n             * The `pathify` functions returns a svg-readable string of the coordinates\n             */\n            const path = pathify({paths: pathData, edge: to?.edge})\n\n            /**\n             * Dummy validation of the path\n             */\n            if (!/\\d/.test(path)) return\n\n            /**\n             * Return the path (d) together with other relevant data such as color, stroke, edge.\n             */\n            return {\n              d: path,\n              ...to,\n            }\n          })\n\n          return pathDataArr\n        })\n        .filter(Boolean)\n        .flat()\n\n      const data = points.filter((p) => Boolean(p))\n\n      setPointsData(data)\n    })\n  }, [elements])\n\n  /**\n   * Handle drag and drop gestures and update the paths\n   */\n  const handleStartInteracting = useCallback(() => {\n    setIsInteracting(true)\n  }, [])\n\n  const handleStopInteracting = useCallback(() => {\n    setIsInteracting(false)\n  }, [])\n\n  const handleUpdateLines = useCallback(() => {\n    if (isInteracting) handleCalcLines()\n  }, [handleCalcLines, isInteracting])\n\n  useEffect(() => {\n    handleCalcLines()\n  }, [handleCalcLines])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleCalcLines, {passive: true})\n    window.addEventListener('scroll', handleCalcLines, {passive: true})\n\n    return () => {\n      window.removeEventListener('resize', handleCalcLines)\n      window.removeEventListener('scroll', handleCalcLines)\n    }\n  }, [handleCalcLines])\n\n  const ro = useMemo(() => new ResizeObserver(handleCalcLines), [handleCalcLines])\n\n  useEffect(() => {\n    elements.forEach((el) => {\n      const element = getElement(el)\n\n      element?.addEventListener('mousedown', handleStartInteracting, {passive: true})\n      element?.addEventListener('mouseup', handleStopInteracting, {passive: true})\n      element?.addEventListener('mousemove', handleUpdateLines, {passive: true})\n      element?.addEventListener('touchstart', handleStartInteracting, {passive: true})\n      element?.addEventListener('touchend', handleStopInteracting, {passive: true})\n      element?.addEventListener('touchmove', handleUpdateLines, {passive: true})\n\n      if (element) {\n        ro.observe(element)\n      }\n    })\n\n    return () => {\n      elements.forEach((el) => {\n        const element = getElement(el)\n\n        element?.removeEventListener('mousedown', handleStartInteracting)\n        element?.removeEventListener('mouseup', handleStopInteracting)\n        element?.removeEventListener('mousemove', handleUpdateLines)\n        element?.removeEventListener('touchstart', handleStartInteracting)\n        element?.removeEventListener('touchend', handleStopInteracting)\n        element?.removeEventListener('touchmove', handleUpdateLines)\n\n        if (element) {\n          ro.disconnect()\n          ro.unobserve(element)\n        }\n      })\n    }\n  }, [\n    elements,\n    handleCalcLines,\n    handleStartInteracting,\n    handleStopInteracting,\n    handleUpdateLines,\n    ro,\n  ])\n\n  return useMemo(\n    () => (\n      <svg style={SVG_STYLE}>\n        {colors?.map((c) => (\n          <defs key={c}>\n            <marker\n              id={`triangle-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"5\"\n              orient=\"auto\"\n              refX=\"1\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={c} />\n              {/* <circle cx=\"5\" cy=\"5\" r=\"5\" fill={c} /> */}\n            </marker>\n            <marker\n              id={`line-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"10\"\n              orient=\"auto\"\n              refX=\"0\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 5 L 10 5\" stroke={c} strokeWidth=\"2\" fill=\"none\" />\n            </marker>\n          </defs>\n        ))}\n\n        {pointsData?.map((p) => {\n          return (\n            <path\n              id=\"p1\"\n              d={p?.d}\n              fill=\"none\"\n              key={p?.d}\n              stroke={p?.color}\n              strokeWidth=\"2\"\n              strokeDasharray={p?.stroke === 'dashed' ? 4 : 0}\n              strokeLinejoin=\"round\"\n              markerEnd={`url(#${p?.hasArrows ? `triangle` : `line`}-${p?.color})`}\n            />\n          )\n        })}\n      </svg>\n    ),\n    [colors, pointsData]\n  )\n}\n","import React from 'react'\nimport {ConnectElementsProvider, useConnectElements} from './elements'\nimport {ConnectLines} from './lines'\n\ninterface ConnectProviderProps {\n  children: React.ReactNode\n}\n\nfunction ConnectProviderInner() {\n  const {elements} = useConnectElements()\n\n  return <ConnectLines elements={elements} />\n}\n\nexport function ConnectProvider(props: ConnectProviderProps) {\n  const {children} = props\n\n  return (\n    <ConnectElementsProvider>\n      {children}\n      <ConnectProviderInner />\n    </ConnectElementsProvider>\n  )\n}\n"],"names":["$c81829298c0be717$export$b18e34ac3520f2e5","$cPJmq$react","createContext","elements","dispatch","$61adfabb2f38684e$export$fc84c22acd302ca7","useContext","Error","$96743ad87b9e841b$export$e1957580bb403527","state","payload","type","id","element","connectWith","exists","some","l","node","next","map","el","x","filter","y","$4e6eeef5ea3a8411$export$5c92df8ce16beba9","props","children","useReducer","ctxVal","useMemo","$cPJmq$reactjsxruntime","jsx","Provider","value","$e800e1848c86903d$export$59e6910693f047c2","nodeRef","useRef","handleAdd","useCallback","current","clone","childProps","cloneElement","ref","useEffect","$7494e3fa284d64f1$export$def641b22e0a4283","paths","edge","p","index","join","$084cb7a41b2ad8c5$export$d16800b7e59a8051","document","querySelector","$7fbeb89c00c7d91a$var$EMPTY_ARRAY","$7fbeb89c00c7d91a$export$790ca4df398846a2","e","length","connectEls","c","a","includes","rect","getBoundingClientRect","color","find","stroke","hasArrows","Boolean","from","to","$23d18a97be95b3fa$export$7709b8005774fb51","fromRect","toRect","position","allowYConnect","left","right","width","bottomToTop","bottom","top","topToBottom","rightToLeft","leftToRight","$23d18a97be95b3fa$var$getPosition","height","$d961c3c0afed5118$var$SVG_STYLE","pointerEvents","$d961c3c0afed5118$var$EMPTY_ARRAY","$d961c3c0afed5118$export$775ba819c8141467","pointsData","setPointsData","useState","isInteracting","setIsInteracting","raf","colors","Set","flat","handleCalcLines","window","cancelAnimationFrame","requestAnimationFrame","data1","data","toArray","pathDataArr","pathData","path","test","d","handleStartInteracting","handleStopInteracting","handleUpdateLines","addEventListener","passive","removeEventListener","ro","ResizeObserver","forEach","observe","disconnect","unobserve","jsxs","style","markerHeight","markerUnits","markerWidth","orient","refX","refY","viewBox","fill","strokeWidth","strokeDasharray","strokeLinejoin","markerEnd","$4f2fb7e80f557106$var$ConnectProviderInner","$4f2fb7e80f557106$export$230737e70939b618"],"version":3,"file":"index.js.map"}