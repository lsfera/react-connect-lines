{"mappings":"iNAGO,MAAMA,EAAyBC,EAA2C,CAC/EC,SAAU,GACVC,SAAU,IAAM,OCFX,SAASC,IAGd,IAFeC,EAAWL,GAGxB,MAAM,IAAIM,MAAM,yBAGlB,OAAOD,EAAWL,GCRb,SAASO,EACdC,EACAC,GAEA,MAAMC,KAACA,EAAIC,GAAEA,EAAEC,QAAEA,EAAOC,YAAEA,GAAeJ,EAEnCK,EAASN,GAAON,UAAUa,MAAMC,GAAMA,EAAEL,KAAOA,IAE/CM,EAAwD,C,GAC5DN,E,QACAC,EACAC,YAJqBA,GAAe,IAOtC,GAAa,QAATH,GAAkBE,EAAS,CAC7B,IAAKE,EACH,MAAO,IACFN,EACHN,SAAU,IAAIM,EAAMN,SAAUe,IAIlC,GAAIH,EAAQ,CACV,MAAMI,EAAO,IAAIV,EAAMN,UAAUiB,KAAKC,GAChCA,EAAGT,KAAOA,EACLM,EAGFG,IAGT,MAAO,IAAIZ,EAAON,SAAUgB,GAG9B,OAAOV,EAGT,MAAa,WAATE,EACK,IACFF,EACHN,SAAUM,EAAMN,SACbiB,KAAKE,IACG,IACFA,EACHR,YAAaQ,EAAER,aAAaS,QAAQC,GAAMA,EAAEZ,KAAOA,QAGtDW,QAAQF,GAAOA,EAAGT,KAAOA,KAIzBH,EC7CF,SAASgB,EAAwBC,GACtC,MAAMC,SAACA,GAAYD,GACZjB,EAAOL,GAAYwB,EAAWpB,EAAwB,CAC3DL,SAAU,GACVC,SAAU,IAAM,OAGZyB,EAASC,GACb,KAAO,CACL3B,SAAUM,EAAMN,SAChBC,SAAUA,KAEZ,CAACK,IAGH,OACEsB,EAAC9B,EAAuB+B,SAAQ,CAACC,MAAOJ,E,SAASF,IChB9C,SAASO,EAAQR,GACtB,MAAMC,SAACA,EAAQf,GAAEA,EAAEE,YAAEA,GAAeY,GAC9BtB,SAACA,GAAYC,IACb8B,EAAUC,IAEVC,EAAYC,GAAY,KAC5BlC,EAAS,CACPO,KAAM,M,GACNC,E,YACAE,EACAD,QAASsB,EAAQI,YAElB,CAACzB,EAAaV,EAAUQ,IAErB4B,EAAQV,GAAQ,KACpB,MAAOJ,MAAOe,GAAcd,EAE5B,OAAOe,EAAaf,EAAU,IACzBc,EACHE,IAAMzB,IACJiB,EAAQI,QAAUrB,EAEM,mBAAbS,GAAyBc,EAAWE,IAAIzB,QAGtD,CAACS,IAeJ,OAbAiB,GAAU,KACRP,MACC,CAACX,EAAOW,EAAWF,IAEtBS,GAAU,IACD,KACLxC,EAAS,CACPO,KAAM,S,GACNC,MAGH,CAACR,EAAUQ,IAEP4B,ECzCF,MAAMK,EAAWnB,IACtB,MAAMoB,MAACA,EAAKC,KAAEA,GAAQrB,EAWtB,MATa,KAAKoB,EACf1B,KAAI,CAAC4B,EAAGC,IACO,IAAVA,GAAwB,SAATF,EAAwB,GAAGC,EAAE1B,KAAK0B,EAAExB,IACzC,IAAVyB,GAAwB,WAATF,EAA0B,KAAKC,EAAE1B,KAAK0B,EAAExB,IAEpD,GAAGwB,EAAE1B,KAAK0B,EAAExB,MAEpB0B,KAAK,QCfH,SAASC,EAAW9B,GACzB,OAAKA,EAAGR,QAIDQ,EAAGR,QAHDuC,SAASC,cAAc,IAAIhC,EAAGT,MCDzC,MAAM0C,EAAkB,GAMjB,SAASC,EAAsB7B,GACpC,MAAMvB,SAACA,GAAYuB,EAmCnB,OA/BgBvB,EACboB,QAAQiC,IAAOA,GAAG1C,aAAewC,GAAaG,OAAS,IACvDrC,KAAKC,IACJ,MAAMP,YAACA,GAAeO,EAIhBqC,EAAavD,EAChBoB,QAAQoC,GAAM7C,GAAaM,KAAKwC,GAAMA,EAAEhD,KAAIiD,SAASF,EAAE/C,MACvDQ,KAAKE,IACG,CACLwC,KAAMX,EAAW7B,IAAIyC,wBACrBC,MAAOlD,GAAamD,MAAML,GAAMA,EAAEhD,KAAOU,EAAEV,MAAKoD,OAAS,UACzDjB,KAAMjC,GAAamD,MAAML,GAAMA,EAAEhD,KAAOU,EAAEV,MAAKmC,MAAQ,SACvDmB,OAAQpD,GAAamD,MAAML,GAAMA,EAAEhD,KAAOU,EAAEV,MAAKsD,QAAU,QAC3DC,UAAWC,QAAQtD,GAAamD,MAAML,GAAMA,EAAEhD,KAAOU,EAAEV,MAAKuD,eAKlE,GAA0B,IAAtBT,EAAWD,OAEf,MAAO,CACLY,KAAM,CACJP,KAAMX,EAAW9B,IAAK0C,yBAExBO,GAAIZ,MAGPnC,OAAO6C,SCdL,SAASG,EAAY7C,GAC1B,MAAM2C,KAACA,EAAIC,GAAEA,GAAM5C,EACb8C,EAAWH,GAAMP,KACjBW,EAASH,GAAIR,KAEnB,IAAKU,IAAaC,EAAQ,OAE1B,MAAMC,EAxBR,SAAqBhD,GACnB,MAAM2C,KAACA,EAAIC,GAAEA,GAAM5C,EAEbiD,EACJN,EAAKO,KANU,GAMUN,EAAGO,OAASR,EAAKQ,MAAQP,EAAGQ,MAAQR,EAAGO,MANjD,GAQXE,EAAcV,EAAKW,OAASV,EAAGW,KAAON,EACtCO,EAAcb,EAAKY,IAAMX,EAAGU,QAAUL,EACtCQ,EAAcd,EAAKO,KAAON,EAAGO,MAC7BO,EAAcf,EAAKQ,MAAQP,EAAGM,KAEpC,OAAIG,EAAoB,gBACpBG,EAAoB,gBACpBC,EAAoB,gBACpBC,EAAoB,qBAAxB,EAUiBC,CAAY,CAAChB,KAAMG,EAAUF,GAAIG,IAElD,OAAQC,GACN,IAAK,gBACH,MAAO,CACL,CACEpD,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,GAAUQ,QAEf,CACE1D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,EAASQ,QAAUR,EAASQ,OAASP,EAAOQ,KAAO,GAExD,CACE3D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGgD,EAASQ,QAAUR,EAASQ,OAASP,EAAOQ,KAAO,GAExD,CACE3D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGiD,EAAOQ,IA9CA,IAmDhB,IAAK,gBACH,MAAO,CACL,CACE3D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,GAAUS,KAEf,CACE3D,EAAGkD,GAAUI,KAAOJ,EAASM,MAAQ,EACrCtD,EAAGgD,EAASS,KAAOT,EAASS,IAAMR,EAAOO,QAAU,GAErD,CACE1D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGgD,EAASS,KAAOT,EAASS,IAAMR,EAAOO,QAAU,GAErD,CACE1D,EAAGmD,GAAQG,KAAOH,EAAOK,MAAQ,EACjCtD,EAAGiD,EAAOO,OAnEA,IAwEhB,IAAK,gBACH,MAAO,CACL,CACE1D,EAAGkD,GAAUI,KACbpD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOI,MAAQL,EAASI,MAAQ,EACpCpD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOI,MAAQL,EAASI,MAAQ,EACpCpD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,GAElC,CACEhE,EAAGmD,EAAOI,MAvFA,EAwFVrD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,IAKtC,IAAK,gBACH,MAAO,CACL,CACEhE,EAAGkD,GAAUK,MACbrD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOG,KAAOJ,EAASK,OAAS,EACpCrD,EAAGgD,GAAUQ,OAASR,EAASc,OAAS,GAE1C,CACEhE,GAAImD,EAAOG,KAAOJ,EAASK,OAAS,EACpCrD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,GAElC,CACEhE,EAAGmD,EAAOG,KA5GA,EA6GVpD,EAAGiD,EAAOQ,IAAMR,EAAOa,OAAS,IAKtC,QACE,MAAO,ICxHb,MAAMC,EAAiC,CACrCb,SAAU,QACVO,IAAK,IACLL,KAAM,IACNC,MAAO,IACPG,OAAQ,IACRQ,cAAe,OACfV,MAAO,OACPQ,OAAQ,QAIJG,EAAkB,GAkBjB,SAASC,EAAahE,GAC3B,MAAOiE,EAAYC,GAAiBC,EAAqBJ,IAClDK,EAAeC,GAAoBF,GAAkB,IACtD1F,SAACA,GAAYuB,EACbsE,EAAM5D,IAMN6D,EAASnE,GACb,IACE,IACK,IAAIoE,IAAI,IACN/F,EAASiB,KAAKoC,GAAMA,EAAE1C,aAAaM,KAAKuC,GAAMA,GAAGK,UAAQmC,OAjChD,aAoCd5E,OAAO6C,UACX,CAACjE,IAGGiG,EAAkB9D,GAAY,KAC9B0D,EAAIzD,SACN8D,OAAOC,qBAAqBN,EAAIzD,SAGlCyD,EAAIzD,QAAU8D,OAAOE,uBAAsB,KAezC,MAuCMC,EAvCqBjD,EAAsB,C,SAACpD,IAG/CiB,KAAKqF,IACJ,MAAMpC,KAACA,EAAMC,GAAIoC,GAAWD,GAAQ,GAE9BE,EAAcD,GAAStF,KAAKkD,IAKhC,MAAMsC,EAAWrC,EAAY,CAACF,KAAMA,EAAMC,GAAIA,IAE9C,IAAKsC,EAAU,OAKf,MAAMC,EAAOhE,EAAQ,CAACC,MAAO8D,EAAU7D,KAAMuB,GAAIvB,OAKjD,MAAK,KAAK+D,KAAKD,GAKR,CACLE,EAAGF,KACAvC,QAPL,KAWF,OAAOqC,KAERpF,OAAO6C,SACP+B,OAEiB5E,QAAQyB,GAAMoB,QAAQpB,KAE1C4C,EAAcY,QAEf,CAACrG,IAKE6G,EAAyB1E,GAAY,KACzCyD,GAAiB,KAChB,IAEGkB,EAAwB3E,GAAY,KACxCyD,GAAiB,KAChB,IAEGmB,EAAoB5E,GAAY,KAChCwD,GAAeM,MAClB,CAACA,EAAiBN,IAErBlD,GAAU,KACRwD,MACC,CAACA,IAEJxD,GAAU,KACRyD,OAAOc,iBAAiB,SAAUf,EAAiB,CAACgB,SAAS,IAC7Df,OAAOc,iBAAiB,SAAUf,EAAiB,CAACgB,SAAS,IAEtD,KACLf,OAAOgB,oBAAoB,SAAUjB,GACrCC,OAAOgB,oBAAoB,SAAUjB,MAEtC,CAACA,IAEJ,MAAMkB,EAAKxF,GAAQ,IAAM,IAAIyF,eAAenB,IAAkB,CAACA,IA4C/D,OA1CAxD,GAAU,KACRzC,EAASqH,SAASnG,IAChB,MAAMR,EAAUsC,EAAW9B,GAE3BR,GAASsG,iBAAiB,YAAaH,EAAwB,CAACI,SAAS,IACzEvG,GAASsG,iBAAiB,UAAWF,EAAuB,CAACG,SAAS,IACtEvG,GAASsG,iBAAiB,YAAaD,EAAmB,CAACE,SAAS,IACpEvG,GAASsG,iBAAiB,aAAcH,EAAwB,CAACI,SAAS,IAC1EvG,GAASsG,iBAAiB,WAAYF,EAAuB,CAACG,SAAS,IACvEvG,GAASsG,iBAAiB,YAAaD,EAAmB,CAACE,SAAS,IAEhEvG,GACFyG,EAAGG,QAAQ5G,MAIR,KACLV,EAASqH,SAASnG,IAChB,MAAMR,EAAUsC,EAAW9B,GAE3BR,GAASwG,oBAAoB,YAAaL,GAC1CnG,GAASwG,oBAAoB,UAAWJ,GACxCpG,GAASwG,oBAAoB,YAAaH,GAC1CrG,GAASwG,oBAAoB,aAAcL,GAC3CnG,GAASwG,oBAAoB,WAAYJ,GACzCpG,GAASwG,oBAAoB,YAAaH,GAEtCrG,IACFyG,EAAGI,aACHJ,EAAGK,UAAU9G,UAIlB,CACDV,EACAiG,EACAY,EACAC,EACAC,EACAI,IAGKxF,GACL,IACE8F,EAAC,MAAG,CAACC,MAAOtC,E,UACTU,GAAQ7E,KAAKuC,GACZiE,EAAC,OAAI,C,UACH7F,EAAC,SAAM,CACLnB,GAAI,YAAY+C,IAChBmE,aAAa,IACbC,YAAY,cACZC,YAAY,IACZC,OAAO,OACPC,KAAK,IACLC,KAAK,IACLC,QAAQ,Y,SAERrG,EAAC,OAAI,CAACgF,EAAE,wBAAwBsB,KAAM1E,MAGxC5B,EAAC,SAAM,CACLnB,GAAI,QAAQ+C,IACZmE,aAAa,IACbC,YAAY,cACZC,YAAY,KACZC,OAAO,OACPC,KAAK,IACLC,KAAK,IACLC,QAAQ,Y,SAERrG,EAAC,OAAI,CAACgF,EAAE,eAAe7C,OAAQP,EAAG2E,YAAY,IAAID,KAAK,aAxBhD1E,KA6BZgC,GAAYvE,KAAK4B,GAEdjB,EAAC,OAAI,CACHnB,GAAG,KACHmG,EAAG/D,GAAG+D,EACNsB,KAAK,OAELnE,OAAQlB,GAAGgB,MACXsE,YAAY,IACZC,gBAA+B,WAAdvF,GAAGkB,OAAsB,EAAI,EAC9CsE,eAAe,QACfC,UAAW,QAAQzF,GAAGmB,UAAY,WAAa,UAAUnB,GAAGgB,UALvDhB,GAAG+D,SAWlB,CAACd,EAAQN,IC3Ob,SAAS+C,IACP,MAAMvI,SAACA,GAAYE,IAEnB,OAAO0B,EAAC2D,EAAY,CAACvF,SAAUA,IAG1B,SAASwI,EAAgBjH,GAC9B,MAAMC,SAACA,GAAYD,EAEnB,OACEkG,EAACnG,EAAuB,C,UACrBE,EACDI,EAAC2G,EAAoB,c","sources":["elements/context.ts","elements/hooks.ts","elements/reducer.ts","elements/provider.tsx","Connect.tsx","lines/utils/pathify.ts","lines/utils/getElement.ts","lines/utils/getGroupedConnections.ts","lines/utils/getPathData.ts","lines/ConnectLines.tsx","ConnectProvider.tsx"],"sourcesContent":["import {createContext} from 'react'\nimport {ConnectElementsContextValue} from '../types'\n\nexport const ConnectElementsContext = createContext<ConnectElementsContextValue>({\n  elements: [],\n  dispatch: () => null,\n})\n","import {useContext} from 'react'\nimport {ConnectElementsContext} from './context'\n\nexport function useConnectElements() {\n  const ctxVal = useContext(ConnectElementsContext)\n\n  if (!ctxVal) {\n    throw new Error('Missing context value')\n  }\n\n  return useContext(ConnectElementsContext)\n}\n","import {ConnectElement, ConnectElementsContextValue, ConnectElementsReducerPayload} from '../types'\n\nexport function connectElementsReducer(\n  state: ConnectElementsContextValue,\n  payload: ConnectElementsReducerPayload\n): ConnectElementsContextValue {\n  const {type, id, element, connectWith} = payload\n\n  const exists = state?.elements?.some((l) => l.id === id)\n  const connectWithArr = connectWith || []\n  const node: ConnectElement & {element?: HTMLElement | null} = {\n    id,\n    element,\n    connectWith: connectWithArr,\n  }\n\n  if (type === 'add' && element) {\n    if (!exists) {\n      return {\n        ...state,\n        elements: [...state.elements, node],\n      }\n    }\n\n    if (exists) {\n      const next = [...state.elements].map((el) => {\n        if (el.id === id) {\n          return node\n        }\n\n        return el\n      })\n\n      return {...state, elements: next}\n    }\n\n    return state\n  }\n\n  if (type === 'remove') {\n    return {\n      ...state,\n      elements: state.elements\n        .map((x) => {\n          return {\n            ...x,\n            connectWith: x.connectWith?.filter((y) => y.id !== id),\n          }\n        })\n        .filter((el) => el.id !== id),\n    }\n  }\n\n  return state\n}\n","import {useMemo, useReducer} from 'react'\nimport {ConnectElementsContext} from './context'\nimport {connectElementsReducer} from './reducer'\n\ninterface ConnectElementsProviderProps {\n  children: React.ReactNode\n}\n\nexport function ConnectElementsProvider(props: ConnectElementsProviderProps) {\n  const {children} = props\n  const [state, dispatch] = useReducer(connectElementsReducer, {\n    elements: [],\n    dispatch: () => null,\n  })\n\n  const ctxVal = useMemo(\n    () => ({\n      elements: state.elements,\n      dispatch: dispatch,\n    }),\n    [state]\n  )\n\n  return (\n    <ConnectElementsContext.Provider value={ctxVal}>{children}</ConnectElementsContext.Provider>\n  )\n}\n","import React, {cloneElement, useCallback, useEffect, useMemo, useRef} from 'react'\nimport {useConnectElements} from './elements'\nimport {ConnectElement} from './types'\n\ninterface ConnectProps extends Omit<ConnectElement, 'element'> {\n  children: React.ReactElement\n}\n\nexport function Connect(props: ConnectProps) {\n  const {children, id, connectWith} = props\n  const {dispatch} = useConnectElements()\n  const nodeRef = useRef<HTMLElement>()\n\n  const handleAdd = useCallback(() => {\n    dispatch({\n      type: 'add',\n      id,\n      connectWith,\n      element: nodeRef.current,\n    })\n  }, [connectWith, dispatch, id])\n\n  const clone = useMemo(() => {\n    const {props: childProps} = children\n\n    return cloneElement(children, {\n      ...childProps,\n      ref: (node: HTMLElement) => {\n        nodeRef.current = node\n\n        if (typeof children === 'function') childProps.ref(node)\n      },\n    })\n  }, [children])\n\n  useEffect(() => {\n    handleAdd()\n  }, [props, handleAdd, nodeRef])\n\n  useEffect(() => {\n    return () => {\n      dispatch({\n        type: 'remove',\n        id,\n      })\n    }\n  }, [dispatch, id])\n\n  return clone\n}\n","import {Edge} from '../../types'\n\ninterface PathifyProps {\n  paths: {x: string | number; y: string | number}[]\n  edge?: Edge\n}\n\nexport const pathify = (props: PathifyProps) => {\n  const {paths, edge} = props\n\n  const path = `M ${paths\n    .map((p, index) => {\n      if (index === 1 && edge === 'step') return `${p.x} ${p.y}`\n      if (index === 1 && edge === 'bezier') return `C ${p.x} ${p.y}`\n\n      return `${p.x} ${p.y}`\n    })\n    .join(' ')}`\n\n  return path\n}\n","import {ConnectElement} from '../../types'\n\nexport function getElement(el: ConnectElement & {element?: HTMLElement}) {\n  if (!el.element) {\n    return document.querySelector(`#${el.id}`)\n  }\n\n  return el.element\n}\n","import {ConnectElement} from '../../types'\nimport {getElement} from './getElement'\n\nconst EMPTY_ARRAY: [] = []\n\ninterface GetGroupedConnectionsProps {\n  elements: ConnectElement[]\n}\n\nexport function getGroupedConnections(props: GetGroupedConnectionsProps) {\n  const {elements} = props\n\n  // const connections = elements?.map((e) => e.connectWith?.map((x) => x?.id)).flat()\n\n  const grouped = elements\n    .filter((e) => (e?.connectWith || EMPTY_ARRAY).length > 0)\n    .map((el) => {\n      const {connectWith} = el\n\n      // const connectionsLen = connections.filter((y) => y === el.id)?.length || 0\n\n      const connectEls = elements\n        .filter((c) => connectWith?.map((a) => a.id).includes(c.id))\n        .map((x) => {\n          return {\n            rect: getElement(x)?.getBoundingClientRect(),\n            color: connectWith?.find((a) => a.id === x.id)?.color || '#000000',\n            edge: connectWith?.find((a) => a.id === x.id)?.edge || 'bezier',\n            stroke: connectWith?.find((a) => a.id === x.id)?.stroke || 'solid',\n            hasArrows: Boolean(connectWith?.find((a) => a.id === x.id)?.hasArrows),\n            // connectionsLen: connectionsLen,\n          }\n        })\n\n      if (connectEls.length === 0) return\n\n      return {\n        from: {\n          rect: getElement(el)?.getBoundingClientRect(),\n        },\n        to: connectEls,\n      }\n    })\n    .filter(Boolean)\n\n  return grouped\n}\n","interface GetPathDataProps {\n  from?: {\n    rect: DOMRect | undefined\n  }\n  to?: {\n    rect: DOMRect | undefined\n  }\n}\n\nconst LINE_OFFSET = 9\nconst POS_OFFSET = 40\n\nfunction getPosition(props: {from: DOMRect; to: DOMRect}) {\n  const {from, to} = props\n\n  const allowYConnect =\n    from.left - POS_OFFSET < to.right && from.right + to.width > to.right - POS_OFFSET\n\n  const bottomToTop = from.bottom < to.top && allowYConnect\n  const topToBottom = from.top > to.bottom && allowYConnect\n  const rightToLeft = from.left > to.right\n  const leftToRight = from.right < to.left\n\n  if (bottomToTop) return 'bottom-to-top'\n  if (topToBottom) return 'top-to-bottom'\n  if (rightToLeft) return 'right-to-left'\n  if (leftToRight) return 'left-to-right'\n}\n\nexport function getPathData(props: GetPathDataProps) {\n  const {from, to} = props\n  const fromRect = from?.rect\n  const toRect = to?.rect\n\n  if (!fromRect || !toRect) return\n\n  const position = getPosition({from: fromRect, to: toRect})\n\n  switch (position) {\n    case 'bottom-to-top': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.bottom,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.bottom - (fromRect.bottom - toRect.top) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.top - LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'top-to-bottom': {\n      return [\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect?.top,\n        },\n        {\n          x: fromRect?.left + fromRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: fromRect.top - (fromRect.top - toRect.bottom) / 2,\n        },\n        {\n          x: toRect?.left + toRect.width / 2,\n          y: toRect.bottom + LINE_OFFSET,\n        },\n      ]\n    }\n\n    case 'right-to-left': {\n      return [\n        {\n          x: fromRect?.left,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.right + fromRect.left) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.right + LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    case 'left-to-right': {\n      return [\n        {\n          x: fromRect?.right,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: fromRect?.bottom - fromRect.height / 2,\n        },\n        {\n          x: (toRect.left + fromRect.right) / 2,\n          y: toRect.top + toRect.height / 2,\n        },\n        {\n          x: toRect.left - LINE_OFFSET,\n          y: toRect.top + toRect.height / 2,\n        },\n      ]\n    }\n\n    default:\n      return []\n  }\n}\n","import {useCallback, useEffect, useMemo, useRef, useState} from 'react'\nimport {ConnectElement, Edge, Stroke} from '../types'\nimport {getElement, getGroupedConnections, getPathData, pathify} from './utils'\n\nconst SVG_STYLE: React.CSSProperties = {\n  position: 'fixed',\n  top: '0',\n  left: '0',\n  right: '0',\n  bottom: '0',\n  pointerEvents: 'none',\n  width: '100%',\n  height: '100%',\n}\n\nconst DEFAULT_COLOR = '#000000'\nconst EMPTY_ARRAY: [] = []\n\ntype PointsData = (\n  | {\n      rect: DOMRect | undefined\n      color: string | undefined\n      edge: Edge\n      stroke: Stroke\n      d: string\n      hasArrows: boolean\n    }\n  | undefined\n)[]\n\ninterface ConnectLinesProps {\n  elements: ConnectElement[]\n}\n\nexport function ConnectLines(props: ConnectLinesProps) {\n  const [pointsData, setPointsData] = useState<PointsData>(EMPTY_ARRAY)\n  const [isInteracting, setIsInteracting] = useState<boolean>(false)\n  const {elements} = props\n  const raf = useRef<number>()\n\n  /**\n   * Create array of all colors configured.\n   * These colors is used to render the svg markers (e.g arrows).\n   */\n  const colors = useMemo(\n    () =>\n      [\n        ...new Set([\n          ...elements.map((e) => e.connectWith?.map((c) => c?.color)).flat(),\n          DEFAULT_COLOR,\n        ]),\n      ].filter(Boolean),\n    [elements]\n  )\n\n  const handleCalcLines = useCallback(() => {\n    if (raf.current) {\n      window.cancelAnimationFrame(raf.current)\n    }\n\n    raf.current = window.requestAnimationFrame(() => {\n      /**\n       * The `getGroupedConnections` function returns:\n       *\n       *  {\n       *    from: DOMRect,\n       *    to: {\n       *       rect: DOMRect,\n       *       color: string,\n       *       edge: string,\n       *       stroke: string,\n       *       hasArrows: boolean\n       *    }[]\n       *  }\n       */\n      const groupedConnections = getGroupedConnections({elements})\n\n      const points = groupedConnections\n        .map((data) => {\n          const {from, to: toArray} = data || {}\n\n          const pathDataArr = toArray?.map((to) => {\n            /**\n             * The `getPathData` function returns an array of objects with\n             * x and y coordinates for the line.\n             */\n            const pathData = getPathData({from: from, to: to})\n\n            if (!pathData) return\n\n            /**\n             * The `pathify` functions returns a svg-readable string of the coordinates\n             */\n            const path = pathify({paths: pathData, edge: to?.edge})\n\n            /**\n             * Dummy validation of the path\n             */\n            if (!/\\d/.test(path)) return\n\n            /**\n             * Return the path (d) together with other relevant data such as color, stroke, edge.\n             */\n            return {\n              d: path,\n              ...to,\n            }\n          })\n\n          return pathDataArr\n        })\n        .filter(Boolean)\n        .flat()\n\n      const data = points.filter((p) => Boolean(p))\n\n      setPointsData(data)\n    })\n  }, [elements])\n\n  /**\n   * Handle drag and drop gestures and update the paths\n   */\n  const handleStartInteracting = useCallback(() => {\n    setIsInteracting(true)\n  }, [])\n\n  const handleStopInteracting = useCallback(() => {\n    setIsInteracting(false)\n  }, [])\n\n  const handleUpdateLines = useCallback(() => {\n    if (isInteracting) handleCalcLines()\n  }, [handleCalcLines, isInteracting])\n\n  useEffect(() => {\n    handleCalcLines()\n  }, [handleCalcLines])\n\n  useEffect(() => {\n    window.addEventListener('resize', handleCalcLines, {passive: true})\n    window.addEventListener('scroll', handleCalcLines, {passive: true})\n\n    return () => {\n      window.removeEventListener('resize', handleCalcLines)\n      window.removeEventListener('scroll', handleCalcLines)\n    }\n  }, [handleCalcLines])\n\n  const ro = useMemo(() => new ResizeObserver(handleCalcLines), [handleCalcLines])\n\n  useEffect(() => {\n    elements.forEach((el) => {\n      const element = getElement(el)\n\n      element?.addEventListener('mousedown', handleStartInteracting, {passive: true})\n      element?.addEventListener('mouseup', handleStopInteracting, {passive: true})\n      element?.addEventListener('mousemove', handleUpdateLines, {passive: true})\n      element?.addEventListener('touchstart', handleStartInteracting, {passive: true})\n      element?.addEventListener('touchend', handleStopInteracting, {passive: true})\n      element?.addEventListener('touchmove', handleUpdateLines, {passive: true})\n\n      if (element) {\n        ro.observe(element)\n      }\n    })\n\n    return () => {\n      elements.forEach((el) => {\n        const element = getElement(el)\n\n        element?.removeEventListener('mousedown', handleStartInteracting)\n        element?.removeEventListener('mouseup', handleStopInteracting)\n        element?.removeEventListener('mousemove', handleUpdateLines)\n        element?.removeEventListener('touchstart', handleStartInteracting)\n        element?.removeEventListener('touchend', handleStopInteracting)\n        element?.removeEventListener('touchmove', handleUpdateLines)\n\n        if (element) {\n          ro.disconnect()\n          ro.unobserve(element)\n        }\n      })\n    }\n  }, [\n    elements,\n    handleCalcLines,\n    handleStartInteracting,\n    handleStopInteracting,\n    handleUpdateLines,\n    ro,\n  ])\n\n  return useMemo(\n    () => (\n      <svg style={SVG_STYLE}>\n        {colors?.map((c) => (\n          <defs key={c}>\n            <marker\n              id={`triangle-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"5\"\n              orient=\"auto\"\n              refX=\"1\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 0 L 10 5 L 0 10 z\" fill={c} />\n              {/* <circle cx=\"5\" cy=\"5\" r=\"5\" fill={c} /> */}\n            </marker>\n            <marker\n              id={`line-${c}`}\n              markerHeight=\"5\"\n              markerUnits=\"strokeWidth\"\n              markerWidth=\"10\"\n              orient=\"auto\"\n              refX=\"0\"\n              refY=\"5\"\n              viewBox=\"0 0 10 10\"\n            >\n              <path d=\"M 0 5 L 10 5\" stroke={c} strokeWidth=\"2\" fill=\"none\" />\n            </marker>\n          </defs>\n        ))}\n\n        {pointsData?.map((p) => {\n          return (\n            <path\n              id=\"p1\"\n              d={p?.d}\n              fill=\"none\"\n              key={p?.d}\n              stroke={p?.color}\n              strokeWidth=\"2\"\n              strokeDasharray={p?.stroke === 'dashed' ? 4 : 0}\n              strokeLinejoin=\"round\"\n              markerEnd={`url(#${p?.hasArrows ? `triangle` : `line`}-${p?.color})`}\n            />\n          )\n        })}\n      </svg>\n    ),\n    [colors, pointsData]\n  )\n}\n","import React from 'react'\nimport {ConnectElementsProvider, useConnectElements} from './elements'\nimport {ConnectLines} from './lines'\n\ninterface ConnectProviderProps {\n  children: React.ReactNode\n}\n\nfunction ConnectProviderInner() {\n  const {elements} = useConnectElements()\n\n  return <ConnectLines elements={elements} />\n}\n\nexport function ConnectProvider(props: ConnectProviderProps) {\n  const {children} = props\n\n  return (\n    <ConnectElementsProvider>\n      {children}\n      <ConnectProviderInner />\n    </ConnectElementsProvider>\n  )\n}\n"],"names":["$232c7e68ffd99198$export$b18e34ac3520f2e5","$blPbz$createContext","elements","dispatch","$4e8c7f5d5460026a$export$fc84c22acd302ca7","$blPbz$useContext","Error","$0f89e9b1b89dbf2f$export$e1957580bb403527","state","payload","type","id","element","connectWith","exists","some","l","node","next","map","el","x","filter","y","$1bc09187a0bc9784$export$5c92df8ce16beba9","props","children","$blPbz$useReducer","ctxVal","$blPbz$useMemo","$blPbz$jsx","Provider","value","$85e2c30641d200de$export$59e6910693f047c2","nodeRef","$blPbz$useRef","handleAdd","$blPbz$useCallback","current","clone","childProps","$blPbz$cloneElement","ref","$blPbz$useEffect","$b273f3fb7075477f$export$def641b22e0a4283","paths","edge","p","index","join","$e0e431770b5811be$export$d16800b7e59a8051","document","querySelector","$1936330569f3f07e$var$EMPTY_ARRAY","$1936330569f3f07e$export$790ca4df398846a2","e","length","connectEls","c","a","includes","rect","getBoundingClientRect","color","find","stroke","hasArrows","Boolean","from","to","$c31a6d62b311d9f6$export$7709b8005774fb51","fromRect","toRect","position","allowYConnect","left","right","width","bottomToTop","bottom","top","topToBottom","rightToLeft","leftToRight","$c31a6d62b311d9f6$var$getPosition","height","$424e118c64b42d36$var$SVG_STYLE","pointerEvents","$424e118c64b42d36$var$EMPTY_ARRAY","$424e118c64b42d36$export$775ba819c8141467","pointsData","setPointsData","$blPbz$useState","isInteracting","setIsInteracting","raf","colors","Set","flat","handleCalcLines","window","cancelAnimationFrame","requestAnimationFrame","data1","data","toArray","pathDataArr","pathData","path","test","d","handleStartInteracting","handleStopInteracting","handleUpdateLines","addEventListener","passive","removeEventListener","ro","ResizeObserver","forEach","observe","disconnect","unobserve","$blPbz$jsxs","style","markerHeight","markerUnits","markerWidth","orient","refX","refY","viewBox","fill","strokeWidth","strokeDasharray","strokeLinejoin","markerEnd","$d9eb0b679a35217c$var$ConnectProviderInner","$d9eb0b679a35217c$export$230737e70939b618"],"version":3,"file":"index.js.map"}